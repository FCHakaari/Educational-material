1) Рефлексия в C#: что это, как можно применять? Как получить поля и методы, используя рефлексию?
Ответ:
	Рефлексия — это механизм, позволяющий получать информацию о типах, их членах (полях, свойствах, методах) и манипулировать ими во время выполнения программы. То есть основная задача рефлексии - это исследование типов.
	Чтобы получить поля и методы используются 3 основных способа:
		- Type type1 = typeof(MyClass);        // через оператор typeof
		- Type type2 = myObject.GetType();     // через экземпляр объекта
		- Type type3 = Type.GetType("Namespace.MyClass"); // по имени типа

2) Dependency Injection (DI): что это такое? Как можно использовать?
Ответ:
	Dependency Injection (DI) — это шаблон проектирования, который реализует принцип Inversion of Control (IoC), позволяющий внедрять зависимости в классы вместо того, чтобы классы сами создавали свои зависимости.
	Основные принципы DI:
	    - Разделение ответственности - класс не должен создавать свои зависимости
	    - Слабая связность - компоненты зависят от абстракций, а не от конкретных реализаций
	    - Тестируемость - легко подменять зависимости для тестирования
	    - Гибкость - можно менять реализацию зависимостей без изменения кода класса
	Как можно использоавть??????????????????????????????????????????????????????????
	
3) Inversion of Control (IoC): в чем заключается идея? Как это можно использовать?
Ответ: 
	Это некий абстрактный принцип, для написания слобосвязанного кода. Суть в том, что каждый компонент системы должен быь как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов 
	
4) Что такое анонимный тип? Что такое анонимный метод?
Ответ: 																			
	Анонимный тип — это тип данных, создаваемый компилятором, без явного объявления класса. Он используется для временного хранения данных, когда не нужно создавать отдельный класс или структуру.
	Особенности:
	    - Не имеют имени – тип генерируется компилятором автоматически.
		- Только для чтения (read-only) – свойства нельзя изменить после создания.
		- Локальная область видимости – используются внутри метода, нельзя вернуть из метода (без приведения к object или dynamic).
		- Сравниваются по значению – два анонимных объекта с одинаковыми свойствами и значениями будут равны.
		  
	Анонимные методы - это способ создания встроенных блоков кода без явного объявления отдельного метода. Они были представлены в C# 2.0 как предшественники лямбда-выражений.
	Основные характеристики:
		- Не имеют имени - определяются непосредственно в месте использования
		- Создаются с помощью ключевого слова delegate
		- Могут быть преобразованы в делегаты
		- Могут захватывать переменные из окружающего контекста (closures)
		
		Пример:
			delegate void SimpleDelegate();
	    	SimpleDelegate del = delegate() { Console.WriteLine("Это анонимный метод") };
		  
5) Что такое делегаты? Как они работают и для чего они нужны?
Ответы:
	Делегаты - это указатели на метод, который позволяет передавать методы как параметры другим методам;
	
6) Для чего используются Lambda-методы? В чем их отличия от обычной реализации методов и функций?
Ответ: 
	Лямбда-функции - это упрощенная форма записи анонимных методов. Удобный способ быстро описать небольшую функцию прямо в коде, особенно когда она нужна только один раз. Они делают код чище и компактнее, но не заменяют обычные методы в сложных сценариях.
	Пример:
		Тип(Делегат/неявный тип) = (параметры) => выражение
		Тип(Делегат/неявный тип) = (параметры) 
		{
			выражение 1
			выражение 2
		}
	Плюсы лямбда-выражений:
		- Краткость — меньше кода, особенно для простых операций.
		- Удобство — не нужно объявлять отдельный метод.
		- Замыкания — могут использовать переменные из внешней области видимости.
		- Широкое применение — LINQ, асинхронность, события, делегаты.

	Минусы:
		- Сложная отладка — анонимные функции сложнее анализировать в отладчике.
		- Не для сложной логики — если код большой, лучше вынести в отдельный метод.
	
7) Жизненный цикл объектов в C#
Ответ:
	В C# жизненный цикл объекта управляется сборщиком мусора (Garbage Collector, GC). Он автоматически освобождает память, когда объекты больше не используются.
	Жизненный цикл объекта разделяется на несколько пунктов:
		- Создание;
		- Использование;
		- Удаление ссылок;
		- Очистка GC;
		- Финализация, если объект использует неуправляемые ресурсы, то нужно очистить используя IDisposable

8) Что такое деструкторы класса? Зачем они нужны? Как их реализовать?
Ответы:
	Деструктор (финализатор) — это специальный метод класса, который автоматически вызывается сборщиком мусора (GC) перед удалением объекта из памяти. Он необходим для освобождения неуправляемых ресурсов и логирования. 
	Пример:
		class Percon
		{
			~Percon(), то есть деструктор должен иметь тоже имя, что и реализуемый класс
			{
			
			}
		}
	
	
	
	
	
	
	
	
	
	
			
	
