																					Продвинутый CSharp
													
													
	1) Рефлексия - это механизм, который позволяет получать информацию о типах, их членах(методы, свойства, поля и события) и атрибутах во время выполнения программы. Она также позволяет динамически создавать экземпляр класса, вызывать методы и получать доступ к закрытым типам(protected, private)
	Основной функционал рефлексии сосредоточен в пространстве имен System.Reflection. 

	Основные классы:
		- Assembly - класс, предстовляющий сборку и позволяет ею манипулировать;
		- AssemblyName - класс, хранящий информацию о сборке;
		- MemberInfo - базовый абстрактный класс, определяющий функционал для классов EventInfo, FieldInfo, MethodInfo и PropertyInfo;
		- EventInfo - класс, хранящий информации о событиях;
		- FieldInfo - класс, хранящий информацию об определенном типе;
		- MethodInfo - класс, хранит информацию об определенном методе;
		- PropertyInfo - хранит информацию о параметре метода;
		- ConstructorInfo - класс, предоставляющий конструктор;
		- Module - класс, позволяющий получить доступ;
		- ParameteInfo - класс, хранящий информацию о параметре метода.

	Чтобы получить информацию о членах типа нужно воспользоваться классом System.Type.
	C помощью класса Type можно получить всю информацию о изучаемом типе:
		- Методы:
			- FindMembers() - возвращает массив объектов MemberInfo данного типы;
			- GetConstructors() - возвращает все конструкторы данного типа в виде набора объектов ConstructorInfo;
			- GetEvents() - возвращает все события данного типа в виде массива объектов EventInfo;
			- GetFields() - возвращает все поля данного типа в виде массива объектов FieldInfo;
			- GetInterfaces() - получает все реализуемые данным типом интерфейсы в виде массива объектов Type;
			- GetMembers() - возвращает все члены типа в виде массива объектов MemberInfo;
			- GetMethods() - получает все методы типа в виде массива объектов MethodInfo;
			- GetProperties() - получает все свойства в виде массива объектов PropertyInfo;
		- Свойства:
			- Name - возвращает имя типа;
			- FullName - возвращает полное имя типа;
			- Namespace - возвращает пространство имен типа;
			- Assembly - возвращает название сборки, где определен тип;
			- Namespace - возвращает название пространства имен, где определен тип;
			- IsArray - возвращает true, если тип является массивом;
			- IsClass - возвращает true, если тип представляет класс;
			- IsValueType - возвращает true, если тип является структурой;
			- IsEnum - возвращает true, если тип является перечислением;
			- IsInterface - возвращает true, если тип представляет интерфейс;
	
	Чтобы управлять типом и получать всю информацию о нем, нам надо сперва получить тип. 
	Это можно сделать 3 способами:
		- typeof(ClassName) - получение типа на этапе компиляции 
		Пример:
			Type myType = typeof(Person);
			Console.WriteLine(myType);  // Person

		- obj.GetType() - получение типа
		Пример:
			Person tom = new Person("Tom");
			Type myType = tom.GetType();
			
		- Type.GetType("Namespace.ClassName") - получение типа по строковому имени 
		Пример:				
			Type? myType = Type.GetType("Person", false, true);
		Разбор работы:
			- Первый параметр указывает на полное имя класса с пространством имен. 
			- Второй параметр указывает, будет ли генерироваться исключение, если класс не удастся найти. В данном случае значение false означает, что исключение не будет генерироваться.
			- Третий параметр указывает, надо ли учитывать регистр символов в первом параметре. Значение true означает, что регистр игнорируется. Поскольку указанный тип может отсутствовать, то метод 				возвращает объект nullable-типа.
			
	Если нужный нам тип находиться в другой сборке, то после полного именни после запятой указываем имя сборки:
		Пример:
			- Type myType = Type.GetType("PeopleTypes.Person, MyLibrary", false, true);
	
	
																				Получение всех компонентов типа
	

	Метод GetMembers() возвращает все доступные компоненты типа в виде объекта MemberInfo. Этот объект позволяет извлечь некоторую информацию о компоненте типа. В частности, некоторые его свойства:
	DeclaringType: возвращает полное название типа.
	MemberType: возвращает значение из перечисления MemberTypes:
		MemberTypes.Constructor
		MemberTypes.Method
		MemberTypes.Field
		MemberTypes.Event
		MemberTypes.Property
		MemberTypes.NestedType
	Name: возвращает название компонента	
		
	Пример:	
		Type myType = typeof(Person);
		foreach (MemberInfo member in myType.GetMembers())
		{
			Console.WriteLine($"{member.DeclaringType} {member.MemberType} {member.Name}");
		}		
			
			
																						BindingFlags
																				
	
	BindingFlags - перечисление, которое используется для управления поиском членов класса(методов, полей, свойств и т.д.) при работе с рефлексией. Позволяет указать какие именно члены нужно искать:
	 - DeclaredOnly - получает только методы непосредственно данного класса, унаследованные методы не извлекаются;
	 - Instance - получает только методы экземпляра;
	 - NonPublic - извлекает не публичные методы;
	 - Public - получает только публичные методы;
	 - Static - получает только статические методы.


------------------------ 
					Посмотреть "Получение информации о методах, Исследование параметров, Получение конструкторов, Получение информации о полях, Получение и изменение значения поля и Свойства"
------------------------


																						Делегаты

			
	Делегат (delegate) — это указатель на метод, который позволяет передавать методы как параметры другим методам.
	
	Используются:		
		- Делегаты позволяют передавать методы как параметры
		- Поддерживают мультиметоды (multicast) с +=  
		- Используются в обработке событий (event) и LINQ
		- Func, Action, Predicate — упрощают работу с делегатами
	
	Встроенные делегаты:		
		- Action<T> - Делегат без возвращаемого значения (void)
		- Func<T, TResult> - Делегат с возвращаемым значением
		- Predicate<T> - Делегат, который возвращает bool
		

																					Анонимные методы
		  
		  
	Анонимные методы - это способ создания встроенных блоков кода без явного объявления отдельного метода. Они были представлены в C# 2.0 как предшественники лямбда-выражений.
	
	Основные характеристики:
		- Не имеют имени - определяются непосредственно в месте использования
		- Создаются с помощью ключевого слова delegate
		- Могут быть преобразованы в делегаты
		- Могут захватывать переменные из окружающего контекста (closures)
		
		Пример:
			delegate void SimpleDelegate();
		    SimpleDelegate del = delegate() { Console.WriteLine("Это анонимный метод") };
		  
			
																					Ламбда-выражения
			
			
	Лямбда-выражения - это компактный способ написания анонимных функций, представленный в C# 3.0. Они представляют собой мощный инструмент для создания делегатов и деревьев выражений.
	
	Action:
		Делегат Название функции = (передача параметров) => действие; 
		Action greet = () = Console.WriteLine("Анонимная функция");
		
	Func:
		Делегат<T1, T2..., T result> название функции = (передача параметров) =>  действие;
		Func<int, int, int> sum = (x, y) => x+y;
		Console.WriteLine($"Сумма - {sum(5, 5)}")
			
	
																					Интерфейс IDisposable
			
			
	Интерфейс IDisposable используется для освобождения неуправляемых ресурсов. Он содержит единственный метод Dispose(), который нужно реализовывать для правильной очистки ресурсов.
	Используют:
		- Очистка неуправляемых ресурсов;
		- Очистка управляемых ресурсов, которые реализуют интерфейс IDisposable
		
	Освобождение неуправляемых ресурсов подразумевает реализацию одного из двух механизмов создание деструктора и реализация классом интерфейса System.IDisposable
			
	Деструктор - это специальный метод который автоматически вызывается сборщиком мусора (GC) перед удалением объекта из памяти. Метод деструктора носит имя класса, но перел которым стоит знак тильда(~)
	Особенности:
		- Класс может иметь только 1 деструктор;
		- Не может иметь модификаторов доступа и параметры;
		- Определить деструкторы можно только в классах.
	Пример:
		class Person
		{
			public string Name { get;}
			public Person(string name) => Name = name;
		 
			~Person()
			{
				Console.WriteLine($"{Name} has deleted");
			}
		}
		
	Деструктор вызывается когда GC определяет объект под удаление, однако при очистке GC вызывает не деструктор, а метод Finalize. Все потому что при компиляции деструктор преобразуется в структуру:
	0
	protected override void Finalize()
	{
		try
		{
		    // здесь идут инструкции деструктора
		}
		finally
		{
		    base.Finalize();
		}
	}
	
	Метод Finalize уже определен в базовом классе Object, однако его нельзя просто переопределить, и фактическая его реализация происходит через создание деструктора. После конца жизненного цикла Person в консоле появиться сообщение об удаление объекта Tom
	Пример:
		GC.Collect();   // очистка памяти под объект tom
		Console.Read(); // ставим задержку
		 
		void Test()
		{
			Person tom = new Person("Tom");
		}
		 
		public class Person
		{
			public string Name { get;}
			public Person(string name) => Name = name;
		 
			~Person()
			{
				Console.WriteLine($"{Name} has been deleted");
			}
		}
		
		
																						Конструкция using
			
			
	Синтаксис C# предлагает похожую конструкцию для автоматического вызова метода Dispose - конструкцию using:
	using (Person tom = new Person("Tom"))
	{
		//
	}
	Получается конструкция using оформляет блок кода и создает объект, который реализует интерфейс IDisposable, в частности метод Dispose. При завершение блока кода у объекта вызывается метод Dispose.
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
