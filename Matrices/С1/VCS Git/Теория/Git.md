#Git #GitHub
___
# Git
#Git #Определения 

- #### Git — это распределенная система контроля версий позволяющая сохранять изменения, внесенные в файлы. Она позволяет нескольким разработчикам удобно работать над одним проектом, сохраняя историю изменений и обеспечивая возможность возврата к предыдущим версиям.

- #### 3 основных состояния фала Git:
	- ##### Modified(Измененный) - файл был  изменен, но еще не проиндексирован для коммита;
	- ##### Staged(Индексированный) - изменённый файл был добавлен в так называемый "staging area". Это подготовленная версия файла, которая войдет в следующий коммит; 
	- ##### Commited(Закоммиченный) - данные безопасно сохранены в локальном репозитории.
---
# Commit
#Commit #Определения 

- #### Коммиты (Commit) - это слепок текущего состояния файла или файлов в рабочей папку. 

- #### Когда создается коммит происходит 2 действия:
	- ##### Если файл не изменялся, то он просто добавляет имя сжатого файл(хеш) в снимок;
	- ##### Если файл изменялся, то он сжимает его, помещает в папку объектов и добавляет имя сжатого файла(хеш) в снимок.

- #### Когда снимок сделан, он также архивируется и именуется при помощи хеша, затем помещается в папку объектов 

- #### Коммит состоит из 4-х элементов:
	- ##### Имя(хеш) - снимок рабочей директории;
	- ##### Комментарий
	- ##### Информация о том, кто выполнил коммит
	- ##### Хеш родительского коммита
---
# Папка .git
#Папка_git #Определения 

- #### Папка .git — это локальный репозиторий, который содержит всю необходимую информацию для отслеживания изменений, введения истории и совместной разработки проекта. Она включает в себя БД объектов, конфигурацию, журналы и другую служебную информацию.

 - #### Структура папки:
	 - ##### HEAD — это указатель на верхушку ветки с которой вы работаете;
	 - ##### Config — этот файл содержит настройки для вашего репозитория, например url репозитория, имя, email и т.п. Каждый раз когда работаем с [[Git часто используемые команды#Git config|Git config]] мы обращаемся к этому файлу;
	 - ##### Description — используется ``` gitweb ```для отображения описания репозитория;
	 - ##### Hooks — эта папка содержит скрипты, которые могут выполняться на различных этапах выполнения Git. Эти скрипты, называются хуками, могут запускаться до/после `git commit/rebase/pull...`. Имя скрипты определяет время его выполнения. Примером хука может служить скрипт проверки стиля перед выполнением команды [[Git часто используемые команды#Git push|Git push]]  в репозиторий;
	 - ##### Info -> Exclude — здесь описываются файлы, которые вы не хотите включать в репозиторий. Функционал этого файла такой же как у .gitignore, за исключением того, что он не передается в репозиторий. На практике обычно для всех задач хватает .gitignore.
___
# Ветка
#Branch #Определения 

- #### Ветка(branch) в Git - это независимая линия разработки, которая позволяет параллельно работать над различными задачами, изменениями или новыми функциями в проекте, не затрагивая основную версию кода.

- #### По умолчанию при создании репозитория создается ветка с именем main. При создании ветки Git копирует текущее состояние проекта.

- #### Основные команды для работы с ветками - [[Git часто используемые команды#Git branch|Git branch]], [[Git часто используемые команды#Git checkout|Git checkout]] и т.п.
---
# Репозиторий 
#Repository #Определения 

- #### Репозиторий(repository) в Git - это хранилище, которое содержит все файлы и историю изменений проекта, включая все ветки, коммиты и теги
	- ##### Есть два вида репозитория:
		- ##### Локальный репозиторий - это репозиторий, который находится на вашем ПК и включает все данные вашего проекта. В локальном репозитории вы можете выполнять основные операции Git. 
		- ##### Удаленный репозиторий - это репозиторий, который размещен на удаленном сервере. Он позволяет совместно работать над проектом с другими людьми. Из локального репозитория можно отправлять изменения в удаленный с помощью команды [[Git часто используемые команды#Git push|Git push]], а также получать изменения с удаленного репозитория с помощью [[Git часто используемые команды#Git pull|Git pull]] или [[Git часто используемые команды#Git fetch|Git fetch]] 

- #### Для создания локального репозитория используется команда [[Git часто используемые команды#Git init|Git init]], либо можем клонировать уже существующий [[Git часто используемые команды#Git clone|Git clone]]

---
#  Слияние веток
#Branch_Merge #Определения 

- #### Слияние веток - это перенос кода из одной ветки в другую. Например, когда мы заканчиваем работу над веткой, сделали новый функционал или поправили багу, мы ее сливаем в мастер(master/main)

- #### Как работает слияние веток:
	- ##### Слияние решений всех изменений из исходной ветки(которую вы хотите слить) в целевую ветку. При этом Git автоматически пытается придумать изменения, но если есть конфликт слияния**, то Git потребует от вас разрешения вручную

- #### Способы слияния веток в Git:
	- #### Обычный merge:
		- ##### Fast-forward ;
		- ##### Трехстороннее слияние; 
	- #### Squash merge;
	- #### Merge с помощью [[Git часто используемые команды#Git  rebase| Get rebase]];
	- #### Octopus merge - для слияния более чем двух веток;

- #### Прямое слияние (fast-forward merge) - происходит, если ветка в которую вы собираетесь сливать, не имела никаких новых коммитов после того, как ветка с изменениями была создана. В этом случае, Git просто перемещает указатель ветки вперед по истории, и все коммиты сливаемой ветки добавляются в эту ветку без создания нового коммита слияния.
	- #### Чтобы это предотвратить используется флаг:
		-  `git merge feature --no--ff`

	- #### Команды для слияния веток : `git merge имя_ветки`, если все пройдет успешно, то Git автоматически сообщает все изменения, создаст новый коммит слияния, который выбирает обе ветки.

- #### Трехстороннее слияние (three-way merge) - используется когда обе ветки имели независимые изменения после ветвления. В этом случае Git создаст новый коммит слияния, который объединяет изменения из обеих веток

- #### Сжатие коммитов (squash merge) - слияние объединяет изменения из сливаемой ветки в одну ветку, но при \том сворачивает все коммиты из этой ветки в один коммит. Это позволяет сохранить изменения, но сделать историю более компактной и читаемой
	- #### Пример команды:	
```CS
		  git checkout main
		  git merge --squash feature-branch
		  git commit
```
- #### После этого все коммиты из ветки `feature-branch` будут объединены в один новый коммит в ветке `main`. Это полезно для того, чтобы избежать большого числа промежуточных коммитов и сохранить чистоту истории  

- #### Перебазирование (Rebase)  - это способ слияния, который позволяет перенести изменения из одной ветки в другую, изменяя историю коммитов. В отличие от обычного слияния, [[Git часто используемые команды#Git rebase|Git rebase]] не создает коммита слияния. Вместо этого он переписывает историю, применяя изменения из одной ветки поверх другой

- #### Слияние более чем двух веток (octopus merge) - используется для слияния более чем двух веток в одну. Это полезно для крупных проектов с несколькими параллельными ветками
	- #### Пример команды:
```CS
		git checkout main
		git merge feature-branch1, feature-branch2 и т.д.
```

- ## Дополнительные стратегии при слиянии веток

- #### Стратегия resolve - классическое трёхстороннее слияние. Стандартный алгоритм трехстороннего слияния применяется для двух файлов с общим предком.
	- #### Пример команды:
		- `git merge feature -s resolve`
	- #### Эта стратегия имеет один недостаток - в качестве общего предка двух веток всегда выбирается наиболее ранний общий коммит

	- #### Стратегия recursive - данная стратегия решает проблемы стратегии resolve. Она так же реализует трехстороннее слияние, но в качестве предка используется не реальный, а "виртуальный" предок, который конструируется по следующему по алгоритму:

		- #### Проводится поиск всех кандидатов на общего предка;
		- #### По цепочке проводится слияние кандидатов, в результате чего появляется новый "Виртуальный" предок, причем более свежие коммиты имеют более высокий приоритет, что позволяет избежать повторного проявления конфликтов.

	- #### Пример команды:
		- `git merge feature -s resolve`
---
# 