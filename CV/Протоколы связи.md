<h1 align="center">SignalR</h1>
#SignalR

---

- ##### SignalR – это библиотека с открытым исходным кодом позволяющая реализовать двухстороннюю связь в реальном времени между клиентом и сервисом.
- ##### Примеры, где может использоваться двухсторонняя связь:
	- ###### Приложения реального времени;
	- ###### Чаты;
	- ###### Онлайн игры;
	- ###### Приложения, требующие частых обновлений от сервера
    
- ##### SignalR предоставляет функционал для создания вызова удаленных процедур между клиентами и сервером, где сервер выступает в роли посредника (RPC**)
- ##### Пример:
	- ###### Клиент A → (вызывает метод на) Сервере.
	- ###### Сервер → (вызывает метод на) Клиенте B (или на всех клиентах, или на группе клиентов).

- ##### Некоторый функционал SignalR для ASP.NET Core:
	- ###### Автоматически обрабатывает управление подключениями;
	- ###### Одновременно отправляет сообщение всем подключенным клиентам;
	- ###### Отправляет сообщение определенным клиентам;
	- ###### Масштабируется для обработки увеличения трафика.

---
- ## Транспорт
---

- ##### SignalR поддерживает следующие методы обработки обмена данными в режиме реального времени:
	- ###### WebSockets**;
	- ###### Server-Sent Events**
	- ###### Long Polling**  

- ##### SignalR автоматически выбирает лучший метод транспорта, который находиться в пределах возможностей сервера и клиента.

---
- ## Hubs
---

- ##### SignalR использует центр для обмена данными между клиентами и серверами.

- ##### Концентратор — это высокоуровневый конвейер, который позволяет клиенту и серверу вызывать методы друг друга. SignalR обрабатывает отправку, позволяя клиентам вызывать методы на сервере и наоборот. В методы можно передавать строго типизированные параметры, которые обеспечивают привязку к модели. SignalR предоставляет два встроенных протокола концентратора: текстовый протокол на основе JSON и двоичный протокол на основе MessagePack**. MessagePack обычно создает небольшие сообщения и быстрее обрабатывается(сериализуется и десериализуется), что снижает нагрузку на сервер и клиент по сравнению с JSON.

- ##### Центры вызывают клиентский код, отправляя сообщения содержащие имя и параметры метода на стороне клиента. Как это работает на стороне клиента:
	- ###### Сервер отправляет сообщение, которое содержит имя целевого метода и параметры.
	- ###### Данные параметров десериализуются** (например, из JSON или MessagePack) с помощью настроенного протокола.
	- ###### Клиент ищет метод с указанным именем в своем коде.
	- ###### При совпадении клиент вызывает этот метод, передавая в него десериализованные данные.
    
- ##### Центры (Hubs) позволяют организовывать подключенных клиентов в группы. После этого можно легко отправлять сообщения всем участникам группы.

- ##### Обработка состояния (State Management):
	- ###### ConnectionId: Каждому подключению автоматически присваивается уникальный идентификатор. Можно отправлять сообщения конкретному подключению: Clients.Client(connectionId).SendAsync(...).
	- ###### Context: В методах хаба на сервере можно получить доступ к контексту вызова (Context), который содержит информацию о текущем подключении (например, Context.ConnectionId, данные аутентификации Context.User, HTTP-запрос и т.д.).    
	- ###### Состояние (State): Между вызовами методов можно хранить данные в состоянии подключения (хотя это часто не рекомендуется для масштабируемости).
    
- ##### Так же при масштабирование может возникнуть проблема:
	- ###### При развертывании на нескольких серверах подключение клиента A идет к Серверу 1, а клиента B — к Серверу 2. Если Сервер 1 попытается отправить сообщение клиенту B, он его не найдет, так как тот подключен к другому серверу.

- ##### Решение:
	- ###### Backplane. SignalR использует так называемый "бэкплейн" (например, Azure SignalR Service, Redis). Все серверы подключаются к этому бэкплейну. Когда сервер получает сообщение, он отправляет его в бэкплейн, который, в свою очередь, перенаправляет его на все остальные серверы. Те серверы, у которых есть целевые клиенты, доставляют им сообщение.

---
- ## Аналоги SignalR
---

- ##### Azure SignalR Service — это официальный managed-аналог для самой SignalR. Вы пишете код на ASP.NET Core точно так же, как и для обычной SignalR, но на этапе запуска добавляете одну строку кода, которая перенаправляет все соединения на масштабируемый управляемый сервис от Microsoft. Это решает главную проблему самостоятельной SignalR — масштабирование на несколько серверов.

- ##### WebSocket API (нативные WebSockets) — стандарт в браузерах и .NET (System.Net.WebSockets).
	- ###### Сходства: Обеспечивает полноценное двустороннее соединение.
	- ###### Различия: Это очень низкоуровневый протокол. Вам самим придется придумывать формат сообщений (часто JSON), механизмы повторного подключения, обработку ошибок, пинг-понг ##### для проверки связи, авторизацию. SignalR использует WebSockets "под капотом", но избавляет вас от всей этой рутины.
---
<h1 align="center">WebSocket</h1>
#WebSocket 

---
- ##### WebSockets — это современный протокол связи, работающий поверх единственного TCP-соединения. Он предоставляет **полнодуплексный (full-duplex)** канал связи между клиентом (например, браузером) и сервером. После установки соединения (рукопожатия) сервер и клиент могут обмениваться данными в реальном времени независимо друг от друга, без необходимости повторных HTTP-запросов.

---
- ## Handshake (рукопожатие)
---

- ##### Что такое "рукопожатие" (handshake) WebSocket?
	- ###### Это первоначальный HTTP-запрос, который инициирует переход с HTTP на протокол WebSocket. Клиент отправляет запрос с заголовками `Upgrade: websocket` и `Connection: Upgrade`, а также специальным ключом. Сервер, если согласен, отвечает с кодом 101 (Switching Protocols) и подтверждением ключа. После этого TCP-соединение переиспользуется для обмена данными по протоколу WebSocket.

---
- ## Отличия от HTTP
---

- ##### Ключевое отличие от HTTP:
	- ###### HTTP (Polling/Long-Polling):** "Вопрос-Ответ". Клиент всегда инициирует запрос, сервер отвечает. Для имитации реального времени используются костыли вроде постоянных опросов (Polling).
	- ###### WebSocket: "Постоянный двусторонний диалог". После рукопожатия сервер может сам отправить данные клиенту в любой момент.

- ##### Применяются там, где нужна мгновенная двухсторонняя передача данных между клиентом и сервером, например: мессенджеры, уведомления

---
- ## Безопасность
---

- ##### Безопасность: WS vs WSS, где WS — не зашифрован, а WSS — зашифрован
	- ###### `ws://` — нешифрованная версия протокола (аналог HTTP). Данные передаются в открытом виде. **Не должен использоваться в продакшене.
	- ###### `wss://` — безопасная, зашифрованная версия (аналог HTTPS). Использует TLS для шифрования трафика. **Является стандартом де-факто для всех проектов.

- ###### В C# для работы с WebSockets можно использовать встроенное пространство имен System.Net.WebSockets или другие библиотеки, такие как: SignalR

- ##### Пример реализации в ASP NET Core:
	```CS
	// Program.cs (Минимальный API)
	app.UseWebSockets(); // Разрешаем Middleware обрабатывать WS запросы
	app.Map("/ws", async (HttpContext context) => {
		if (context.WebSockets.IsWebSocketRequest)
		{
			using var webSocket = await context.WebSockets.AcceptWebSocketAsync();
			await Echo(webSocket);
		}
		else
		{
			context.Response.StatusCode = StatusCodes.Status400BadRequest;
		}
	});
	
	private static async Task Echo(WebSocket webSocket)
	{
		var buffer = new byte[1024 * 4];
		// Ждем данные от клиента
		var receiveResult = await webSocket.ReceiveAsync(
			new ArraySegment<byte>(buffer), CancellationToken.None);
	
		while (!receiveResult.CloseStatus.HasValue)
		{
			// Отправляем полученные данные обратно клиенту (Эхо-сервер)
			await webSocket.SendAsync(
				new ArraySegment<byte>(buffer, 0, receiveResult.Count),
				receiveResult.MessageType,
				receiveResult.EndOfMessage,
				CancellationToken.None);
	
			// Ждем следующую порцию данных
			receiveResult = await webSocket.ReceiveAsync(
				new ArraySegment<byte>(buffer), CancellationToken.None);
		}
	
		// Закрываем соединение корректно
		await webSocket.CloseAsync(
			receiveResult.CloseStatus.Value,
			receiveResult.CloseStatusDescription,
			CancellationToken.None);
	}
	``` 

---
<h1 align="center">Server-Sent Events</h1>
#Server-Sent-Events 

---

- ##### Server-Sent Event (SSE) - предоставляет еще одну технологию взаимодействия клиента и сервера, которая позволяет серверу отправлять сообщению клиенту. Стоить отметить. что в отличие от WebSockets, коммуникация через SSO является однонаправленной, то есть от сервера к клиенту. 

---
<h1 align="center">RPC</h1>
#RPC

---
- ##### RPC - это протокол, который позволяет программе на одном компьютере вызывать процедуры или функции, расположенные на другом компьютере, как если бы они были локальными. Это обеспечивает распределенную обработку, где клиент может инициировать выполнение кода на сервере, получая результат обратно.

---
- ## Суть RPC
---

- ##### RPC абстрагирует сетевое взаимодействие, позволяя разработчикам думать о вызовах процедур, как о локальных не заботясь о деталях передачи данных и сетевых протоколах.

- ### Пример работа на рисунке

![[Pasted image 20250822161641.png]]

---
<h1 align="center">gRPC</h1>
#gRPC

---

- ##### gRPC использует HTTP/2 в качестве транспортного протокола. HTTP/2 обеспечивает более эффективное использование сетевых ресурсов по сравнению с HTTP/1.1, позволяя множеству запросов и ответов передаваться параллельно в рамках одного TCP-соединения. Это уменьшает задержки и увеличивает общую производительность.

- ##### gRPC обычно использует Protocol Buffers, язык описания интерфейсов и систему сериализации от Google, в качестве формата для структурирования данных. ProtoBuf позволяет определять структуру данных и интерфейсы сервисов в специальных файлах `.proto`. Эти файлы компактны, эффективны и позволяют автоматически генерировать исходный код для различных языков программирования.

---
- ## Ключевые особенности
---

- ##### Использование HTTP/2:
	- ###### Мультиплексирование — несколько запросов/ответов через одно TCP-соединение
	- ###### Бинарный протокол — более эффективный чем текстовый HTTP/1.1
	- ###### Server Push — сервер может отправлять данные без запроса от клиента
	- ###### Приоритизация потоков — оптимизация порядка обработки запросов
    
- ##### Protocol Buffers (Protobuf):
	- ###### Язык-независимый формат сериализации
	- ###### Бинарный формат — меньше размер данных чем JSON/XML
	- ###### Схема и контракты — строгая типизация через `.proto` файлы
	- ###### Автогенерация кода для клиентов и серверов 

- ##### Кроссплатформенность
	- ###### Поддержка **10+ языков** программирования
	- ###### Единая спецификация через `.proto` файлы
	- ###### Совместимость между разными технологическими стеками

---
- ## Protobuf
- --

- #### Protobuf — это бинарный формат обмена данными. Разработан был для быстрой и компактной передачи структурированной информации. Чаще используется для внутреннего обмена данными между сервисами

---
<h1 align="center">REST API</h1>
#REST_API

---

##### REST — это архитектурный стиль для проектирования распределительных систем REST разделен на 6 основных принципов:
- ###### Клиент-серверная модель — клиент и сервер разделены и функционируют независимо;
- ###### Отсутствие состояния(stateless) — означает, что сервер не запоминает предыдущие действия пользователя и каждый новый запрос должен быть единому образу со всей необходимой информацией;    
- ###### Кэширование — означает, что у каждого ответа сервера должна быть пометка выполняется кэширование или нет, обычно используется там, где много однотипных запросов;    
- ###### Единообразие интерфейса (uniform interface) — означает, что интерфейсы должны быть унифицированными, чтобы клиент/сервер понимали в каком формате отправлять/возвращать запросы;    
- ###### Многоуровневая система — означает, что между клиентом и сервером могут находиться дополнительные структуры, такие как промежуточный сервер. Концепция заключается в том, что никто из участников не знает всего пути, только соседей слева и справа.    
- ###### Код по требованию — сервер может передавать исполняемый код клиенту

- ##### Плюсы REST-архитектуры:
	- ###### Просто и понятность, использует стандартные HTTP-методы;
	- ###### Масштабируемость
	- ###### Независимость клиента-сервера

- ##### Основные CRUD операции:
	- ###### Create — Post;
	- ###### Read — Get;
	- ###### Update — Put/Patch;
	- ###### Delete — Delete.

- ##### HTTP Методы:
	- ###### GET - получение ресурса
	- ###### POST - создание ресурса
	- ###### PUT - полное обновление ресурса
	- ###### PATCH - частичное обновление ресурса
	- ###### DELETE - удаление ресурса
	- ###### HEAD - получение метаданных
	- ###### OPTIONS - получение поддерживаемых методов

HTTP Status Codes

- ##### 1xx - Информационные
- ##### 2xx - Успех
	- ###### `200 OK` - успешный запрос
	- ###### `201 Created` - ресурс создан
	- ###### `204 No Content` - успешно, но нет тела ответа
- ##### 3xx - Перенаправление
	- ###### 307 — временное перенаправление
	- ###### 308 — постоянное перенаправление
- ##### 4xx - Ошибка клиента
	- ###### `400 Bad Request` - неверный запрос
	- ###### `401 Unauthorized` - не авторизован
	- ###### `403 Forbidden` - доступ запрещен
	- ###### `404 Not Found` - ресурс не найден
	- ###### `409 Conflict` - конфликт состояний
- ##### 5xx - Ошибка сервера
	- ###### `500 Internal Server Error` - внутренняя ошибка
	- ###### `503 Service Unavailable` - сервис недоступен
